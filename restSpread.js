/*
In this section, we'll be exploring the rest
operator, which is an operator that will
help us write less code. Now, for this part
we'll be revisiting the reduce helper. Let's
get started by writing a function that takes
a sum of an array.
*/

function addNumbersArray(numbers) {
	return numbers.reduce((sum, number) =>
  	 sum + number, 0);
}

addNumbersArray([1, 2, 3, 4, 5]);

/*
Let's think... what if we wanted to pass in
the numbers to be summed as arguments not
in an array, but as comma-separated values?
Like so: addNumbers(1, 2, 3, 4, 5);

We would have a variable number of
arguments, because we don't know how many
we'll be using. How would we make this
possible?

The purpose of the rest operator is to
capture a comma-separated list of arguments,
and make them easier to handle. We don't
need a pre-defined number of arguments
either, which adds flexibility.
*/

/*
How does it work? We use ...arguments, to
dictate that we're passing in an unknown
amount of arguments.
*/

function addNumbersCommaSeparated(...numbers) {
return numbers.reduce((sum, number) =>
  	 sum + number, 0);
}

addNumbersCommaSeparated(2, 4, 6, 8, 10);

/*
Closely related to the rest operator is the
spread operator. We can think of the rest
operator as gathering variables, and the
spread operator as flattening or spreading
them out.

Let's see how this works with an example.
Say we are displaying a palette of colours.
This palette will have default colours and
some custom ones that are generated by users.
*/

const defaultColors = ['red', 'green'];
const userFavoriteColors = ['orange', 'yellow'];
const fallColors = ['fire red', 'fall orange'];

/*
Let's say we want to join these colors
together. The traditional way would be to
use the array concat helper, which
definitely works.
*/

defaultColors.concat(userFavoriteColors);

/*
But let's use the spread operator to achieve
the same effect.
*/

[...defaultColors, ...userFavoriteColors ];

/*
What's happening here? First, we created a
new array. Inside it, we referenced an
existing arrays with '...' which takes
its elements and adds them to our new array
in order. Note that the result is not a
nested array, but some sort of flattened
array.

We can add as many arrays to be flattened,
and add single elements as usual. And we can
specify the order too!
*/

[
  'blue',
  ...fallColors,
  ...defaultColors,
  ...userFavoriteColors
];

/*
Let's cover another example. Let's say we
have a function whose job is to validate a
given shopping list. The number of items in
the shopping list is not known, so we use
the spread operator.
*/

function validateShoppingList(...items) {
  if (items.indexOf('milk') < 0) {
    /*
    We add milk onto the top of the list
    if milk isn't on the list.
    */
    return ['milk', ...items];
  }
  return items;
}

validateShoppingList('orange', 'bread', 'egg');
